"""
*** BEGIN LICENSE INFORMATION ***

The contents of this file are subject to the Common Public Attribution License 
Version 1.0 (the "License"); you may not use this file except in compliance with 
the License. You may obtain a copy of the License at 
http://lass.sourceforge.net/cpal-license. The License is based on the 
Mozilla Public License Version 1.1 but Sections 14 and 15 have been added to cover 
use of software over a computer network and provide for limited attribution for 
the Original Developer. In addition, Exhibit A has been modified to be consistent 
with Exhibit B.

Software distributed under the License is distributed on an "AS IS" basis, WITHOUT 
WARRANTY OF ANY KIND, either express or implied. See the License for the specific 
language governing rights and limitations under the License.

The Original Code is LASS - Library of Assembled Shared Sources.

The Initial Developer of the Original Code is Bram de Greve and Tom De Muer.
The Original Developer is the Initial Developer.
	
All portions of the code written by the Initial Developer are:
Copyright (C) 2004-2007 the Initial Developer.
All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms of the
GNU General Public License Version 2 or later (the GPL), in which case the 
provisions of GPL are applicable instead of those above.  If you wish to allow use
of your version of this file only under the terms of the GPL and not to allow 
others to use your version of this file under the CPAL, indicate your decision by 
deleting the provisions above and replace them with the notice and other 
provisions required by the GPL License. If you do not delete the provisions above,
a recipient may use your version of this file under either the CPAL or the GPL.

*** END LICENSE INFORMATION ***
"""

# last commit: 
# $Revision$
# $Date$
# $Author$

import re
import string
import sys
import time



maxLevel = 3
begins = ['<', '\{', '\[', '\(']
ends = ['>', '\}', '\]', '\)']
now = time.asctime()



def _resolver(matchobj, i):
	character = matchobj.group(1)
	if character == 'x':
		return str(i)
	elif character == 'y':
		return str(i + 1)
	elif character == 'g':
		return 'Generated by param_expander.py on %s' % now
	else:
		return character



""" substitute instances of $x, $y and $g, except if it's preceeded by a second $ like $$x .... """
def _substitute(text, i):
		r = re.compile(r'\$(.)', re.MULTILINE | re.DOTALL)
		return r.sub(lambda x: _resolver(x, i), text)



def _expand(matchobj,n,level):
	parts = [_substitute(_scan(matchobj.group(2), i + 1, level + 1), i + 1) for i in range(n)]
	joint = ', '
	if '\n' in matchobj.group(2):
		joint = ''
	expanded = string.join(parts, joint)
	return string.join([matchobj.group(1), expanded, matchobj.group(3)], '')

	
def _scan(text, n, level):
	if level > maxLevel:
		return text	
	r = re.compile(r'([^$]|\A)\$' + begins[level] + r'(.*?)' + ends[level] + r'\$([^$]|\Z)', 
				re.MULTILINE | re.DOTALL)
	text = r.sub(lambda x: _expand(x,n,level), text)
	text = _scan(text, n, level + 1)
	text = _substitute(text, n)	
	return text



def _generateFile(outFileName, text, i):
	print outFileName,
	try:
		outFile = file(outFileName, 'r')
		currentContent = outFile.read()
		outFile.close()
	except:
		currentContent = ""
	newContent = expand(text, i)
	if newContent != currentContent:
		outFile = file(outFileName, 'w')
		outFile.write(newContent)
		outFile.close()
		print "updated"
	else:
		print "still up to date"


"""
Expands parameters in text to the size of i
	"""
def expand(text, i):
	return _scan(text, i, 0)



"""
Expands parameters in file inFileName to the size of n and save in file outFileName.
If outFileName contains $x then for each value i in range [1, n], an output file
with $x being replaced by i will be generated, and in each of these files the parameters
will be expanded to the size of i instead of n.
	"""
def expandFile(inFileName, outFileName, n):
	inFile = open(inFileName, 'r')
	text = inFile.read()
	inFile.close()
	if re.search(r'\$x', outFileName):
		r = re.compile(r'\$x', re.MULTILINE | re.DOTALL)
		for i in range(n):
			_generateFile(r.sub(str(i + 1), outFileName), text, i + 1)
	else:
		_generateFile(outFileName, text, n)



def main(argv):
	argc = len(argv)
	if argc == 4:
		expandFile(argv[1], argv[2], int(argv[3]))


if __name__ == "__main__":
	main(sys.argv)


# History:
#
# $Log$
# Revision 1.5  2005/11/04 00:36:01  bramz
# *** empty log message ***
#
# Revision 1.4  2005/05/23 19:26:26  bramz
# some operator changes to colors and images
#
# Revision 1.3  2004/11/28 17:08:11  bramz
# fixed bug revealed by python2.4 and improved substitution scheme
#
# Revision 1.2  2004/09/13 16:07:15  bramz
# *** empty log message ***
#
# Revision 1.1  2004/09/13 14:55:18  bramz
# porting param_expander from perl to python
#
#
# EOF
