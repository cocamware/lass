# last commit: 
# $Revision$
# $Date$
# $Author$

use strict;
use warnings;

my $max_level = 3;
my @begins = ('<', '\{', '\[', '\(');
my @ends = ('>', '\}', '\]', '\)');
my $now = localtime;

sub expand
{
	my ($pre, $text, $post, $n, $level) = @_;

	my @parts;
	for (my $k = 1; $k <= $n; ++$k)
	{
		$parts[$k - 1] = $level < $max_level ? scan($text, $k, $level + 1) : $text;
		my $x = $k;	$parts[$k - 1] =~ s/([^\$]|\A)\$x/$1$x/sg;
		my $y = $k + 1; $parts[$k - 1] =~ s/([^\$]|\A)\$y/$1$y/sg;
	}

	my $joint = ($text =~ /\n/ ? "" : ", ");
	my $expanded = join $joint, @parts;

	return "$pre$expanded$post";
}

sub scan
{
	my ($text, $n, $level) = @_;

	my ($begin, $end) = ($begins[$level], $ends[$level]);
	$text =~ s/([^\$]|\A)\$$begin(.*?)$end\$([^\$]|\Z)/expand($1, $2, $3, $n, $level)/sge;

	if ($level < $max_level)
	{
		$text = scan($text, $n, $level + 1);
	}

	my $x = $n;	$text =~ s/([^\$]|\A)\$x/$1$x/sg;
	my $y = $n + 1;	$text =~ s/([^\$]|\A)\$y/$1$y/sg;
	$text =~ s/([^\$]|\A)\$g/$1Generated by param_expander.pl on $now/sg;
	$text =~ s/([^\$]|\A)\$\$/$1\$/sg;

	return $text;
}

sub generate
{
	my ($text, $out_file, $i) = @_;
	print "$out_file\n";
	open(OUT, ">$out_file") or die "couldn't open $out_file: $!";
	print OUT scan($text, $i, 0);
	close OUT;
}	

# ---------------------------------------

my ($in_file, $out_file, $n) = @ARGV;

open(IN, "<$in_file") or die "couldn't open $in_file: $!";
local $/ = undef;
my $text = <IN>;
close IN;

if ($out_file =~ /\$x/)
{
	for (my $i = 1; $i <= $n; ++$i)
	{
		my $tmp = $out_file;
		$tmp =~ s/\$x/$i/;
		generate($text, $tmp, $i);
	}
}
else
{
	generate($text, $out_file, $n);
}

# History:
#
# $Log$
# Revision 1.5  2004/07/26 20:11:28  bdegreve
# added variabled $y that equals to $x + 1, so use it whenever you need $x + 1 :)
#
# Revision 1.4  2004/06/22 14:05:04  bdegreve
# unrecognized $ tags are left unchanged
# e.g. $a remains $a instead of becoming a
#
#
# EOF
